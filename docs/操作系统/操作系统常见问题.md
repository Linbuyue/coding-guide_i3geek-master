## 1、进程和线程的区别

（1）定义：进程是系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，一个进程包括多个线程，是CPU调度和分派的基本单位。
（2）资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。
（3）共享：进程在执行过程中拥有独立的内存单元,而多个线程共享内存。

注：CPU中调度的是线程，多CPU是多线程运行，不是多进程。进程是通过不断的切换看似并行。

## 2、并发和并行

并发：同一时间间隔内发生多件事务。在微观上不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行，从宏观外来看，好像是这些进程都在执行。这就好像两个人用同一把铁锨，轮流挖坑，一小时后，两个人各挖一个小一点的坑，要想挖两个大一点得坑，一定会用两个小时

并行：是指无论从微观还是宏观，二者都是一起执行的。就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。 

从以上本质不难看出，“并发”执行，在多个进程存在资源冲突时，并没有从根本提高执行效率。

## 3、进程调度算法（先来先服务FCFS，短作业优先，抢占和非抢占优先级法） 

先来先服务：按照队列的顺序
短作业优先：对短作业或短进程优先调度的算法，从后备队列中选择一个估计运行时间最短的作业/进程
非抢占优先级法：按照优先级处理完当前再处理下一个
抢占式优先级法：只要遇到优先级比当前高的，立即停止切换下一个。

## 4、进程间通信方式（管道、信号量、消息队列、信号、共享内存、套接字）

- 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
- 有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
- 信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
- 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
- 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
- 套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

## 5、线程间通信（互斥锁 条件变量 信号量机制） 

- 锁机制：包括互斥锁、条件变量、读写锁
   *互斥锁提供了以排他方式防止数据结构被并发修改的方法。
   *读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
   *条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
- 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量
   
注意：线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

## 6、进程同步（哲学家进餐厅）

进程间的同步与互斥：信号量

## 7、死锁原因、必要条件、处理死锁 （银行家算法）、临界区

死锁：是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用, 它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的,当某个进程提出申请资源后,使得有关进程在无外力协助下,永远分配不到必需的资源而 无法继续运行,这就产生了一种特殊现象死锁。

必要条件：
1)互斥条件:指进程对所分配到的资源进行排它性使用,即在一段时间内某资源只由一个进程占用。如果此 时还有其它进程请求资源,则请求者只能等待,直至占有资源的进程用毕释放。 
2)请求和保持条件:指进程已经保持至少一个资源,但又提出了新的资源请求,而该资源已被其它进程占有, 此时请求进程阻塞,但又对自己已获得的其它资源保持不放。 
3)不剥夺条件:指进程已获得的资源,在未使用完之前,不能被剥夺,只能在使用完时由自己释放。 
4)环路等待条件:指在发生死锁时,必然存在一个进程——资源的环形链,即进程集合{P0,P1,P2,·,Pn}中的 P0 正在等待一个 P1 占用的资源;P1 正在等待 P2 占用的资源,„„,Pn 正在等待已被 P0 占用的资源。

处理死锁：
1) 预防死锁。这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件,去破坏产生死锁的四个必要条件中的一个或者几个,来预防发生死锁。预防死锁是一种较易实现的方法,已被广泛使用。但是由于所施加的限制条件往往太严格,可能会导致系统资源利用率和系统吞吐量降低。
2) 避免死锁。该方法同样是属于事先预防的策略,但它并不须事先采取各种限制措施去破坏产生死锁的的四个必要条件,而是在资源的动态分配过程中,用某种方法去防止系统进入不安全状态,从而避免发生死锁。
3)检测死锁。这种方法并不须事先采取任何限制性措施,也不必检查系统是否已经进入不安全区,此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构,及时地检测出死锁的发生,并精确地确定与死锁有关的进程和资源,然后采取适当措施,从系统中将已发生的死锁清除掉。
4)解除死锁。这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时,须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程,以便回收一些资源,再将这些资源分配给已处于阻塞状态的进程,使之转为就绪状态,以继续运行

临界区：指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待。 

## 8、分页和分段的区别

http://www.w2bc.com/Article/86892
1）页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于系统管理的需要，而不是用户的需要。
段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好的满足用户的需要。
2）页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。
段的长度却不固定，决定于用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。
3）分页的作业地址空间是维一的，即单一的线性空间，程序员只须利用一个记忆符，即可表示一地址。
分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。

分段机制：是指将程序所需要的内存空间大小的虚拟空间,通过映射机制映射到某个物理地址空间(映射的操作由硬件完成)。
分段映射机制解决了之前操作系统存在的两个问题:(1)地址空间没有隔离。(2)程序运行的地址不确定。分段方法中,程序所需要的空间会一并在内存中分配,因此空间要么被整体换入,要么被整体换出;不存在由于内存不足而引起的重新申请更多的内存空间的问题。 

分页机制。解决了上面分段方法所存在的一个内存使用效率问题;其核心思想是系统为程序执行文件中的第 x 页分 配了内存中的第 y 页,同时 y 页会添加到进程虚拟空间地址的映射表中(页表),这样程序就可以通过映射访问到内 存页 y 了。 分页的基本方法是将地址空间人为地等分成某一个固定大小的页;每一页大小由硬件来决定,或者是由操作系统来 决定(如果硬件支持多种大小的页)。目前,以大小为 4KB 的分页是绝大多数 PC 操作系统的选择。 关于进程分页。当我们把进程的虚拟地址空间按页来分割,常用的数据和代码会被装在到内存;暂时没用到的是数 据和代码则保存在磁盘中,需要用到的时候,再从磁盘中加载到内存中即可。
 
## 9、页面置换算法（最佳置换、先进先出置换、LRU、Clock算法）

最佳置换OPT：（理想置换算法）替换最长时间不需要访问的页面
先进先出FIFO：按照队列的顺序
最近最久未使用LRU：替换在最近一段时间内最久不用的页面
时钟Clock：类似轮询，初始标记位0 加入或者使用时标记为1，替换标记为0的，当全部为1时 遍历并全更换为0